# Ledger System Architecture & Design Patterns

## 1. Core Philosophy: The "Dumb but Strict" Ledger
This project implements a **Double-Entry Ledger** using Domain-Driven Design (DDD). The core philosophy is that the Ledger is a low-level financial infrastructure component.

*   **It assumes** the caller knows *why* money is moving.
*   **It verifies** that the movement is mathematically balanced (Debits = Credits).
*   **It enforces** consistency and data integrity.

## 2. Terminology & DDD Models

We follow standard accounting patterns (as defined by Martin Fowler and used by modern fintechs like Stripe and Modern Treasury).

*   **Transaction (`Transaction`)**: Represents a single financial event (e.g., "Alice pays Bob"). It is the **Aggregate Root**. It guarantees atomicity: either all entries happens, or none do.
*   **Posting (`Posting`)**: Represents a single line item within a transaction (e.g., "Debit Account A $100").
    *   *Note:* Previously called "Entry", renamed to "Posting" to align with "Posting a Transaction" terminology.
*   **Money (`Money`)**: A Value Object encapsulating Amount and Currency. Prevents currency mismatch errors (e.g., adding USD to EUR).

## 3. The "Posting" Pattern vs. "Transfer" Pattern

A common question is: *Why not just have a `transfer(from, to, amount)` method?*

While "Transfers" are common, a real-world ledger must handle more complex scenarios:
1.  **Split Payments:** Paying a $50 bill split between two friends.
2.  **Platform Fees:** A $100 payment where $97 goes to the merchant and $3 goes to the platform.
3.  **Multi-Leg Transactions:** Escrow movements, tax withholding, etc.

### Our Approach: Caller Constructs, Ledger Validates
The `postTransaction` API is generic. It accepts a list of **Postings**.

**The Workflow:**
1.  **Caller (Domain Service/Frontend):** Determines the business logic.
    *   *Example:* "This is a transfer with a 3% fee."
    *   *Action:* Constructs 3 Postings: Debit (User), Credit (Merchant), Credit (Revenue Account).
2.  **Ledger:** Receives the list.
    *   *Validation:* Checks `Sum(Debits) == Sum(Credits)`.
    *   *Execution:* Updates balances atomically.

This separation of concerns allows the Ledger to be stable and reusable, regardless of how complex the business rules above it become.

## 4. Industry Standards Validation

This architecture aligns with major financial infrastructure providers:

*   **Stripe Treasury:** Uses `Transaction` objects composed of `TransactionEntries` to model money movement.
*   **Modern Treasury:** Explicitly separates "Ledger Transactions" (the container) from "Ledger Entries" (the debits/credits). They rely on the caller to define these entries.
*   **Martin Fowler (Accounting Patterns):** Defines `Accounting Transaction` as the encapsulation of multiple balanced `Entries`.

## 5. Technical Implementation Details
*   **Hexagonal Architecture:** The domain logic is isolated from the web (API) and persistence (JPA) layers.
*   **ID Generation:** Transaction IDs are generated by the Domain Factory `Transaction.create()`, ensuring the domain entity is always valid upon creation.
*   **JPA Persistence:** We use `TransactionJpaEntity` and `PostingJpaEntity` for persistence, mapping them to/from the pure Domain objects.

## 6. Event Sourcing & Immutability
While this implementation currently uses a state-based persistence (saving the current state of Accounts and Transactions), the Domain Model is designed to be compatible with **Event Sourcing** principles.

*   **Immutable History:** `Transaction` objects are never updated or deleted. They are strictly **appended**.
*   **Corrections via Reversal:** If a mistake is made (e.g., wrong amount), we do **not** edit the database row. Instead, we insert a **Reversal Transaction** (swapping Debits and Credits) to neutralize the error, and then post the correct transaction. This preserves the audit trail.
*   **Deriving State:** The current balance of an `Account` is technically the sum of all past `Postings` for that account. Currently, we cache this balance in the `Account` entity for performance, but it can always be reconstructed from the history.

## 7. References & Further Reading

*   **Martin Fowler - Accounting Patterns:** Foundational patterns for accounting software.
    *   [Accounting Narrative](https://martinfowler.com/eaaDev/AccountingNarrative.html)
    *   [Account Pattern](https://martinfowler.com/eaaDev/Account.html)
    *   [Accounting Entry Pattern](https://martinfowler.com/eaaDev/AccountingEntry.html)
*   **Stripe Treasury API:** Real-world example of Transaction/Entry separation.
    *   [Stripe Treasury Docs](https://stripe.com/docs/treasury)
*   **Modern Treasury:**
    *   [Ledger API Concepts](https://docs.moderntreasury.com/reference/ledger-transactions)
